<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LargeSVM: largeVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="largeSVM.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">LargeSVM
   </div>
   <div id="projectbrief">Library for Large-Scale, Non-linear, Multi-Class Problems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classlarge_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">largeVector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class which handles high-dimensional vectors.  
 <a href="classlarge_vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="large_s_v_m_8h_source.html">largeSVM.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for largeVector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlarge_vector.png" usemap="#largeVector_map" alt=""/>
  <map id="largeVector_map" name="largeVector_map">
<area href="classlarge_vector_a_m_m.html" title="Class which holds sparse vector, which is split into a number of arrays to trade-off between speed of..." alt="largeVectorAMM" shape="rect" coords="0,56,121,80"/>
<area href="classlarge_vector_b_s_g_d.html" title="Class which holds sparse vector, which is split into a number of arrays to trade-off between speed of..." alt="largeVectorBSGD" shape="rect" coords="131,56,252,80"/>
<area href="classlarge_vector_l_l_s_v_m.html" title="Class which holds sparse vector, which is split into a number of arrays to trade-off between speed of..." alt="largeVectorLLSVM" shape="rect" coords="262,56,383,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abade0afbb14475380813f3e620a69020"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#abade0afbb14475380813f3e620a69020">getID</a> (void)</td></tr>
<tr class="memdesc:abade0afbb14475380813f3e620a69020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classlarge_vector.html#adf8518fb0a753c60b35dcd59ea77c312">weightID</a>, a unique ID of a vector.  <a href="#abade0afbb14475380813f3e620a69020"></a><br/></td></tr>
<tr class="separator:abade0afbb14475380813f3e620a69020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200da9e51bff8bc8825ffa40a694f2fe"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a200da9e51bff8bc8825ffa40a694f2fe">operator[]</a> (int idx) const </td></tr>
<tr class="memdesc:a200da9e51bff8bc8825ffa40a694f2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded [] operator that returns a vector element stored in <a class="el" href="classlarge_vector.html#af8b7a3311c2240b4d0c08790aea80744">array</a>.  <a href="#a200da9e51bff8bc8825ffa40a694f2fe"></a><br/></td></tr>
<tr class="separator:a200da9e51bff8bc8825ffa40a694f2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b02d3a9219caf7a3b2701913ce1977"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#aa4b02d3a9219caf7a3b2701913ce1977">operator[]</a> (int idx)</td></tr>
<tr class="memdesc:aa4b02d3a9219caf7a3b2701913ce1977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded [] operator that assigns a value to vector element stored in <a class="el" href="classlarge_vector.html#af8b7a3311c2240b4d0c08790aea80744">array</a>.  <a href="#aa4b02d3a9219caf7a3b2701913ce1977"></a><br/></td></tr>
<tr class="separator:aa4b02d3a9219caf7a3b2701913ce1977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae610fa00368fef725cd8ef7bb3f708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a4ae610fa00368fef725cd8ef7bb3f708">largeVector</a> (long dim=0, long chnkWght=0)</td></tr>
<tr class="memdesc:a4ae610fa00368fef725cd8ef7bb3f708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initializes the vector to all zeros.  <a href="#a4ae610fa00368fef725cd8ef7bb3f708"></a><br/></td></tr>
<tr class="separator:a4ae610fa00368fef725cd8ef7bb3f708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c47cfb3e65d029511c8a75f92770456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c47cfb3e65d029511c8a75f92770456"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a4c47cfb3e65d029511c8a75f92770456">~largeVector</a> ()</td></tr>
<tr class="memdesc:a4c47cfb3e65d029511c8a75f92770456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, cleans up the memory. <br/></td></tr>
<tr class="separator:a4c47cfb3e65d029511c8a75f92770456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca1fd6f8a53ccc4837c7e1e923b25b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#aeca1fd6f8a53ccc4837c7e1e923b25b0">createVectorUsingDataPoint</a> (<a class="el" href="classlarge_data.html">largeData</a> *inputData, unsigned long t, <a class="el" href="structparameters.html">parameters</a> *param)</td></tr>
<tr class="memdesc:aeca1fd6f8a53ccc4837c7e1e923b25b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new support vector from training data point.  <a href="#aeca1fd6f8a53ccc4837c7e1e923b25b0"></a><br/></td></tr>
<tr class="separator:aeca1fd6f8a53ccc4837c7e1e923b25b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db5e0f04af3ae721a6e2b8bb766abd2"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a4db5e0f04af3ae721a6e2b8bb766abd2">sqrNorm</a> (void)</td></tr>
<tr class="memdesc:a4db5e0f04af3ae721a6e2b8bb766abd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a squared norm of the vector.  <a href="#a4db5e0f04af3ae721a6e2b8bb766abd2"></a><br/></td></tr>
<tr class="separator:a4db5e0f04af3ae721a6e2b8bb766abd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0544de2ca7726398f14bd83cffa7f87"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#ac0544de2ca7726398f14bd83cffa7f87">gaussianKernel</a> (<a class="el" href="classlarge_vector.html">largeVector</a> *otherVector, <a class="el" href="structparameters.html">parameters</a> *param)</td></tr>
<tr class="memdesc:ac0544de2ca7726398f14bd83cffa7f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Gaussian kernel kernel between this and other vector stored in <a class="el" href="classlarge_vector.html">largeVector</a>.  <a href="#ac0544de2ca7726398f14bd83cffa7f87"></a><br/></td></tr>
<tr class="separator:ac0544de2ca7726398f14bd83cffa7f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1628239d2a817e5c8652947c7a89061"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#ae1628239d2a817e5c8652947c7a89061">gaussianKernel</a> (unsigned int t, <a class="el" href="classlarge_data.html">largeData</a> *inputData, <a class="el" href="structparameters.html">parameters</a> *param)</td></tr>
<tr class="memdesc:ae1628239d2a817e5c8652947c7a89061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Gaussian kernel kernel between this and other vector from input data stored in <a class="el" href="classlarge_data.html">largeData</a>.  <a href="#ae1628239d2a817e5c8652947c7a89061"></a><br/></td></tr>
<tr class="separator:ae1628239d2a817e5c8652947c7a89061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900dc0a7c629890b52c874bf6fde2976"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a900dc0a7c629890b52c874bf6fde2976">linearKernel</a> (unsigned int t, <a class="el" href="classlarge_data.html">largeData</a> *inputData, <a class="el" href="structparameters.html">parameters</a> *param)</td></tr>
<tr class="memdesc:a900dc0a7c629890b52c874bf6fde2976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes linear kernel between vector and given input data point.  <a href="#a900dc0a7c629890b52c874bf6fde2976"></a><br/></td></tr>
<tr class="separator:a900dc0a7c629890b52c874bf6fde2976"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adf8518fb0a753c60b35dcd59ea77c312"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#adf8518fb0a753c60b35dcd59ea77c312">weightID</a></td></tr>
<tr class="memdesc:adf8518fb0a753c60b35dcd59ea77c312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique ID of the current vector, used in AMM batch when assigning vectors to data points.  <a href="#adf8518fb0a753c60b35dcd59ea77c312"></a><br/></td></tr>
<tr class="separator:adf8518fb0a753c60b35dcd59ea77c312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b7a3311c2240b4d0c08790aea80744"><td class="memItemLeft" align="right" valign="top">vector&lt; float * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#af8b7a3311c2240b4d0c08790aea80744">array</a></td></tr>
<tr class="memdesc:af8b7a3311c2240b4d0c08790aea80744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of vector chunks, element of the array is NULL if all features within a chunk represented by the element are equal to 0.  <a href="#af8b7a3311c2240b4d0c08790aea80744"></a><br/></td></tr>
<tr class="separator:af8b7a3311c2240b4d0c08790aea80744"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a11e57934f08783a0eabe9030276d99cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11e57934f08783a0eabe9030276d99cb"></a>
static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a11e57934f08783a0eabe9030276d99cb">dimension</a> = 0</td></tr>
<tr class="memdesc:a11e57934f08783a0eabe9030276d99cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensionality of the vector. <br/></td></tr>
<tr class="separator:a11e57934f08783a0eabe9030276d99cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c754749d135382736b873df1c2d2c8"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#af1c754749d135382736b873df1c2d2c8">id</a> = 0</td></tr>
<tr class="memdesc:af1c754749d135382736b873df1c2d2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of the vector.  <a href="#af1c754749d135382736b873df1c2d2c8"></a><br/></td></tr>
<tr class="separator:af1c754749d135382736b873df1c2d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659a5f59d4d0e6e5309463bdac9cf232"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#a659a5f59d4d0e6e5309463bdac9cf232">arrayLength</a> = 0</td></tr>
<tr class="memdesc:a659a5f59d4d0e6e5309463bdac9cf232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vector chunks.  <a href="#a659a5f59d4d0e6e5309463bdac9cf232"></a><br/></td></tr>
<tr class="separator:a659a5f59d4d0e6e5309463bdac9cf232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78e4fa1fd0b9b8ae23a629f6e00b24e"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarge_vector.html#ac78e4fa1fd0b9b8ae23a629f6e00b24e">chunkWeight</a> = 0</td></tr>
<tr class="memdesc:ac78e4fa1fd0b9b8ae23a629f6e00b24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the vector chunk (implemented as an array).  <a href="#ac78e4fa1fd0b9b8ae23a629f6e00b24e"></a><br/></td></tr>
<tr class="separator:ac78e4fa1fd0b9b8ae23a629f6e00b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which handles high-dimensional vectors. </p>
<p>In order to handle high-dimensional vectors (i.e., data points), we split the data vector into a number of chunks (i.e., arrays), and allocate memory for each chunk only if it contains at least one element that is non-zero. This is especially beneficial for very sparse data sets, where we can have considerable memory gains. Each chunk has a pointer to it, and the pointer is NULL if the chunk has all zero elements; non-NULL pointer points to an array that stores the elements of the vector. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4ae610fa00368fef725cd8ef7bb3f708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">largeVector::largeVector </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>chnkWght</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, initializes the vector to all zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensionality of the vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chnkWght</td><td>Size of each vector chunk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aeca1fd6f8a53ccc4837c7e1e923b25b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void largeVector::createVectorUsingDataPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarge_data.html">largeData</a> *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structparameters.html">parameters</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new support vector from training data point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>Input data from which t-th vector is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Index of the input vector in the input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The parameters of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates new support vector from a training point. Simply copies the non-zero elements of the data point to the support vector. </p>

</div>
</div>
<a class="anchor" id="ac0544de2ca7726398f14bd83cffa7f87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double largeVector::gaussianKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarge_vector.html">largeVector</a> *&#160;</td>
          <td class="paramname"><em>otherVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structparameters.html">parameters</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes Gaussian kernel kernel between this and other vector stored in <a class="el" href="classlarge_vector.html">largeVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVector</td><td>The second input vector to RBF kernel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The parameters of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of RBF kernel between two vectors.</dd></dl>
<p>Function computes the value of Gaussian kernel between two vectors. </p>

</div>
</div>
<a class="anchor" id="ae1628239d2a817e5c8652947c7a89061"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double largeVector::gaussianKernel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlarge_data.html">largeData</a> *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structparameters.html">parameters</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes Gaussian kernel kernel between this and other vector from input data stored in <a class="el" href="classlarge_data.html">largeData</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Index of the input vector in the input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>Input data from which t-th vector is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The parameters of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of RBF kernel between two vectors.</dd></dl>
<p>Function computes the value of Gaussian kernel between two vectors. </p>

</div>
</div>
<a class="anchor" id="abade0afbb14475380813f3e620a69020"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long largeVector::getID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <a class="el" href="classlarge_vector.html#adf8518fb0a753c60b35dcd59ea77c312">weightID</a>, a unique ID of a vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Unique ID of a vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a900dc0a7c629890b52c874bf6fde2976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double largeVector::linearKernel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlarge_data.html">largeData</a> *&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structparameters.html">parameters</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes linear kernel between vector and given input data point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Index of the input vector in the input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>Input data from which t-th vector is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The parameters of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of linear kernel between two input vectors.</dd></dl>
<p>Function computes the dot product of <a class="el" href="classlarge_vector.html">largeVector</a> vector, and the input data point from <a class="el" href="classlarge_data.html">largeData</a>. </p>

<p>Reimplemented in <a class="el" href="classlarge_vector_a_m_m.html#a017f33648c8dd7ceec6bffec5235f09d">largeVectorAMM</a>.</p>

</div>
</div>
<a class="anchor" id="a200da9e51bff8bc8825ffa40a694f2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float largeVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded [] operator that returns a vector element stored in <a class="el" href="classlarge_vector.html#af8b7a3311c2240b4d0c08790aea80744">array</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of vector element that is retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4b02d3a9219caf7a3b2701913ce1977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float &amp; largeVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded [] operator that assigns a value to vector element stored in <a class="el" href="classlarge_vector.html#af8b7a3311c2240b4d0c08790aea80744">array</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of vector element that is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the modified element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4db5e0f04af3ae721a6e2b8bb766abd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double largeVector::sqrNorm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a squared norm of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Squared norm of the vector. </dd></dl>

<p>Reimplemented in <a class="el" href="classlarge_vector_a_m_m.html#a1a4448e97490b85ccd963ebedd64440e">largeVectorAMM</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af8b7a3311c2240b4d0c08790aea80744"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float * &gt; largeVector::array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of vector chunks, element of the array is NULL if all features within a chunk represented by the element are equal to 0. </p>
<p>When the data is sparse, then we do not have to explicitly store every feature as most of them are equal to 0. One option is simply to follow LIBSVM format, and store in two linked lists feature index and the corresponing feature value. However, we found that traversing this data structure can become prohibitively slow, as for high-dimensional data weights can become less sparse than the original data, due to the weight update process. We address this by storing a vector essentially into linked list, but with elements of a list not individual features but several features stored in an array. If all elements of this "vector chunk" are zero, we do not allocate memory for the appropriate element of the array. In our experience, this significantly improved the training and testing time on truly high-dimensional data, such as on URL data set with more than 3.2 million features. If <a class="el" href="structparameters.html#a95e3c939fd0f1f555d850fabc3a46b4d">parameters::CHUNK_WEIGHT</a> is equal to 1, we obtain the LIBSVM-type representation. </p>

</div>
</div>
<a class="anchor" id="a659a5f59d4d0e6e5309463bdac9cf232"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long largeVector::arrayLength = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of vector chunks. </p>
<p>In order to deal with high-dimensional data, each vector is split into several chunks, and the memory for the chunk is not allocated if all elements of a vector are equal to 0. The static variable<a class="el" href="classlarge_vector.html#ac78e4fa1fd0b9b8ae23a629f6e00b24e">chunkWeight</a> specifies how many of these chunks are used to represent each vector. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structparameters.html#a95e3c939fd0f1f555d850fabc3a46b4d" title="Size of chunk of largeVector weight (whole vector is split into smaller parts) (default: 1...">parameters::CHUNK_WEIGHT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac78e4fa1fd0b9b8ae23a629f6e00b24e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long largeVector::chunkWeight = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Length of the vector chunk (implemented as an array). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structparameters.html#a95e3c939fd0f1f555d850fabc3a46b4d" title="Size of chunk of largeVector weight (whole vector is split into smaller parts) (default: 1...">parameters::CHUNK_WEIGHT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1c754749d135382736b873df1c2d2c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long largeVector::id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ID of the vector. </p>
<p>Each vector is uniquely identifiable using its ID. This is used in AMM batch algorithm, where weights and data points are matched, and we need to know which weight (represented as <a class="el" href="classlarge_vector.html">largeVector</a> ), belongs to which data points. </p>

</div>
</div>
<a class="anchor" id="adf8518fb0a753c60b35dcd59ea77c312"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int largeVector::weightID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unique ID of the current vector, used in AMM batch when assigning vectors to data points. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classlarge_vector.html#af1c754749d135382736b873df1c2d2c8" title="ID of the vector.">id</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="large_s_v_m_8h_source.html">largeSVM.h</a></li>
<li>largeSVM.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 8 2013 19:22:26 for LargeSVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
